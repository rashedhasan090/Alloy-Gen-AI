['A labeled transition system (LTS) is comprised by States, a sub-set\n', 'of which are Initial, connected by transitions, here represented by \n', 'Events.\n', 'sig State {\n', '        trans : Event -> State\n', '}\n', 'sig Init in State {}\n', 'sig Event {}\n', 'The LTS does not contain deadlocks, ie, each state has at least a \n', 'transition.\n', 'pred inv1 {\n', '\tall s: State | some s.trans \n', '}\n', 'There is a single initial state.\n', 'pred inv2 {\n', '\tone Init \n', '}\n', 'The LTS is deterministic, ie, each state has at most a transition for each event.\n', 'pred inv3 {\n', '\tall s : State, e : Event | lone e.(s.trans) \n', '}\n', 'All states are reachable from an initial state.\n', 'pred inv4 {\n', '    let tr = { s1, s2 : State | some e : Event | s1->e->s2 in trans } |\n', '        State in Init.^tr\n', '}\n', 'All the states have the same events available.\n', 'pred inv5 {\n', '\tall s:State, s1:State | s.trans = s1.trans }\n', 'Each event is available in at least a state.\n', 'pred inv6 {\n', '\tall e:Event | some s1,s2:State | s1->e->s2 in trans }\n', 'The LTS is reversible, ie, from a reachable state it is always possible \n', 'to return to an initial state.\n', 'pred inv7 {\n', '    let tr = { s1, s2 : State | some e : Event | s1->e->s2 in trans } |\n', '        all s : Init.^tr | some i : Init | i in s.^tr\n', '}\n', 'pred inv1_OK {\n', '\tall s: State | some s.trans }\n', 'assert inv1_Repaired {\n', '    inv1[] iff inv1_OK[]\n', '}\n', '---------\n', 'pred inv2_OK {\n', '\tone Init }\n', 'assert inv2_Repaired {\n', '    inv2[] iff inv2_OK[]\n', '}\n', '--------\n', 'pred inv3_OK {\n', '\tall s : State, e : Event | lone e.(s.trans) }\n', 'assert inv3_Repaired {\n', '    inv3[] iff inv3_OK[]\n', '}\n', '--------\n', 'pred inv4_OK {\n', '    let tr = { s1, s2 : State | some e : Event | s1->e->s2 in trans } |\n', '        State in Init.^tr\n', '}\n', 'assert inv4_Repaired {\n', '    inv4[] iff inv4_OK[]\n', '}\n', '--------\n', 'pred inv5_OK {\n', '\tall s:State, s1:State | s.trans = s1.trans }\n', 'assert inv5_Repaired {\n', '    inv5[] iff inv5_OK[]\n', '}\n', '--------\n', 'pred inv7_OK {\n', '    let tr = { s1, s2 : State | some e : Event | s1->e->s2 in trans } |\n', '        all s : Init.^tr | some i : Init | i in s.^tr\n', '}\n', 'assert inv7_Repaired {\n', '    inv7[] iff inv7_OK[]\n', '}\n', '--------\n', '--- PerfectOracleCommands\n', ' check inv1_Repaired expect 0\n', ' check inv2_Repaired expect 0\n', ' check inv3_Repaired expect 0\n', ' check inv4_Repaired expect 0\n', ' check inv5_Repaired expect 0\n', ' check inv7_Repaired expect 0\n', 'pred repair_pred_1{inv1[] iff inv1_OK[] }\n', 'run repair_pred_1\n', 'assert repair_assert_1{inv1[] iff inv1_OK[] }\n', 'check repair_assert_1\n']