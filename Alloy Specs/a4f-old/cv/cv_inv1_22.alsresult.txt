The bug in the code is that there is no constraint on the relationship between the source and the works added to a user's profile. The fixed code below adds such a constraint to inv2.

abstract sig Source {}
sig User extends Source {
    profile : set Work,
    visible : set Work
}
sig Institution extends Source {}
sig Id {}
sig Work {
    ids : some Id,
    source : one Source
}

// Specify the following invariants!
// You can check their correctness with the different commands and
// specifying a given invariant you can assume the others to be true.

pred inv1 {
    all u:User | u.visible in u.profile
}

pred inv2 {
    all u:User, w:Work {
        w in u.profile implies
            ((u in w.source) or (some i:Institution | i in w.source))
            and (w.source in u.~profile.source)
    }
}

pred inv3 {
    all w1, w2 : Work, u : User | w1 != w2 and (w1 + w2) in u.profile 
        and (w1.source = w2.source) implies no w1.ids & w2.ids
}

/*======== IFF PERFECT ORACLE ===============*/

pred inv1_OK {
    all u:User | u.visible in u.profile
}

assert inv1_Repaired {
    inv1[] iff inv1_OK[]
}

---------

pred inv2_OK {
    all u:User, w:Work {
        w in u.profile implies
            ((u in w.source) or (some i:Institution | i in w.source))
            and (w.source in u.~profile.source)
    }
}

assert inv2_Repaired {
    inv2[] iff inv2_OK[]
}

--------

pred inv3_OK {
    all w1, w2 : Work, u : User | w1 != w2 and (w1 + w2) in u.profile 
        and (w1.source = w2.source) implies no w1.ids & w2.ids
}

assert inv3_Repaired {
    inv3[] iff inv3_OK[]
}


-- PerfectOracleCommands
check inv1_Repaired expect 0
check inv2_Repaired expect 0
check inv3_Repaired expect 0 

pred repair_pred_1{inv1[] iff inv1_OK[] }
run repair_pred_1
assert repair_assert_1{inv1[] iff inv1_OK[] }
check repair_assert_1