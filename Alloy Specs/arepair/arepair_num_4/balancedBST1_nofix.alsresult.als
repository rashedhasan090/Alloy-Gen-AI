Bug: 

In part (a) of the specification, the second line should say `// A node cannot have more than one child.` instead of `// A node cannot have more than one parent.`.

Fixed specification:

['one sig BinaryTree {\n', '  root: lone Node\n', '}\n', '\n', 'sig Node {\n', '  left, right: lone Node,\n', '  elem: Int\n', '}\n', '\n', '// All nodes are in the tree.\n', 'fact Reachable {\n', '  Node = BinaryTree.root.*(left + right)\n', '}\n', '\n', '// Part (a)\n', 'fact Acyclic {\n', '  all n : Node {\n', '    // There are no directed cycles, i.e., a node is not reachable\n', '    // from itself along one or more traversals of left or right.\n', '    -- TODO: Your code starts here.\n', '\t\tn !in n.^(left + right)\n', '    // A node cannot have more than one child.\n', '    -- TODO: Your code starts here.\n', '\t\tlone n.~(left + right)\n', '    // A node cannot have another node as both its left child and\n', '    // right child.\n', '    -- TODO: Your code starts here.\n', '\t\tno n.left & n.right \n', '  }\n', '}\n', '\n', '// Part (b)\n', 'pred Sorted() {\n', '  all n: Node {\n', "    // All elements in the n's left subtree are smaller than the n's elem.\n", '    -- TODO: Your code starts here.\n', '\t\tsome n.left => all child : n.left.*(left+right) | n.elem > child.elem\n', "    // All elements in the n's right subtree are bigger than the n's elem.\n", '    -- TODO: Your code starts here.\n', '\t\tsome n.right => all child : n.right.*(left+right) | n.elem < child.elem\n', '  }\n', '}\n', '\n', '// Part (c.1)\n', 'pred HasAtMostOneChild(n: Node) {\n', '  // Node n has at most one child.\n', '  -- TODO: Your code starts here.\n', '\t!(some n.left && some n.right)\n', '}\n', '\n', '// Part (c.2)\n', 'fun Depth(n: Node): one Int {\n', "  // The number of nodes from the tree's root to n.\n", '  -- TODO: Your code starts here.\n', '\t#(n.^~(left + right))\n', '}\n', '\n', '// Part (c.3)\n', 'pred Balanced() {\n', '  all n1, n2: Node {\n', '    // If n1 has at most one child and n2 has at most one child,\n', '    // then the depths of n1 and n2 differ by at most 1.\n', '    // Hint: Be careful about the operator priority.\n', '    -- TODO: Your code starts here.\n', '\t\t(HasAtMostOneChild[n1] && HasAtMostOneChild [n2]) => ( minus[Depth[n1], Depth[n2]] <= 1 && minus[Depth[n1], Depth[n2]] >= -1)\n', '  }\n', '}\n', '\n', '\n', '\n', 'assert repair_assert_1{\n', '\tall n : Node | some n => Depth[n] = #(n.*~(left+right))\n', '}\n', 'check repair_assert_1\n', '\n', 'pred repair_pred_1{\n', '\tall n : Node | some n => Depth[n] = #(n.*~(left+right))\n', '}\n', 'run repair_pred_1']